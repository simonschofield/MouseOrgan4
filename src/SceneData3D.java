import java.awt.Color;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Scanner;

///////////////////////////////////////////////////////////////////////////////
// Scene3D and DepthBuffer data image dimensions are generated by another package
// You will probably have them roughly the same aspect as your Main Document Image.
// To keep the interface working betweenthe two sets of dimensions, access to
// Scene3D data is using a converter which first converts MO Doc space
// into Normalized space (both x and y in the range 0..1)
//
// To keep the interface easy within the MouseOrgan user session, Document Space
// (0..1 in the longest edge, 0.. <1 in the shorter edge of the Mouse Organ Document)
// is used, then conveted to Normalized space for further use, hence you initialise the 
// SceneDtat3D class with the Mouse Organ Document Aspect

public class SceneData3D {
	// path to the specified input scenedata folder
	String directoryPath;
	
	
	// view data from the original 3D scene
	PVector cameraPosition;
	PVector cameraLookat;
	
	
	CoordinateSpaceConverter coordinateSpaceConverter;
	
	// document aspect is the aspect of the
	// output compositer render, not the input roi
	float mouseOrganDocAspect;
	
	// the with and height of the renders and depth images (should all be the same)
	int renderWidth;
	int renderHeight;
	
	// The renders in the scenedata are (probably) a crop of a larger view (the "original view"). This data is used to add offsets back into the geometry calculation.
	// Specifically, the FOV is for the whole original view before it was cropped. We need to recover the correct vector into the scene
	// for 3D and depth calculations. The viewROICrop is used to add offsets to the X and Y of pixels to enable this.
	// 
	int originalViewWidth;
	int originalViewHeight;
	Rect originalViewCropRect;
	
	
	// this reads in and contains all the png files within the input folder
	DirectoryImageGroup renderImages;
	BufferedImage currentRenderKeyImage;
	boolean currentRenderKeyImageHasAlpha;
	
	// depth stuff. The depthImage is normalised to 0..1 after loading
	// but the original min and max depth are kept so the
	// original depths can be recalculated
	
	Range originalDepthExtrema;
	GeometryBuffer3D geometryBuffer3d;
	DistanceBufferFilter distanceFilter;
	FloatImage distanceImage;
	float fov;
	
	public SceneData3D(float docAspect, DistanceBufferFilter dFilter) {
		mouseOrganDocAspect = docAspect;
		distanceFilter = dFilter;
	}
	
	public SceneData3D(float docAspect) {
		mouseOrganDocAspect = docAspect;
		distanceFilter = new DistanceBufferFilter();
	}

	public void load(String targetDirectory) {
		directoryPath = targetDirectory;
		load();
	}
		
    public void load(){
		renderImages = new DirectoryImageGroup(directoryPath, ".png", "");
		renderImages.loadContent();
		
		// this is a "distance" image, it is converted to a proper depth image
		// in the DepthBuffer object
		distanceImage = new FloatImage(directoryPath + "\\distance.data");

		// the render width of the images in the scenedata folder should be all the same
		renderWidth = distanceImage.getWidth();
		renderHeight = distanceImage.getHeight();

		// from the view.txt file....
		// read the FOV
		ArrayList<String> strList = MOUtils.readTextFile(directoryPath + "\\view.txt");
		String fovString = strList.get(2);
		fov = Float.parseFloat(fovString);
		
		// read the original view width and height
		String originalViewWidthString = strList.get(3);
		originalViewWidth = Integer.parseInt(originalViewWidthString);
		
		String originalViewHeightString = strList.get(4);
		originalViewHeight = Integer.parseInt(originalViewHeightString);
		
		// read the crop of the original view
		String topleftSt = strList.get(5);
		String botRighSt = strList.get(6);
		
		PVector topLeftV = new PVector();
		topLeftV.fromString(topleftSt);
		
		PVector botRighV = new PVector();
		botRighV.fromString(botRighSt);
		
		
		originalViewCropRect = new Rect(topLeftV,botRighV);
		
		int originalViewOffsetX = originalViewWidth - (int)originalViewCropRect.left;
		int originalViewOffsetY = originalViewHeight - (int)originalViewCropRect.top;
		
		coordinateSpaceConverter = new CoordinateSpaceConverter(renderWidth,renderHeight, mouseOrganDocAspect);
		
		
		geometryBuffer3d = new GeometryBuffer3D(distanceImage, fov, coordinateSpaceConverter, distanceFilter, originalViewWidth, originalViewHeight, originalViewOffsetX, originalViewOffsetY);
		
		setCurrentRenderImage(0);
	}
    
    
    void setDistanceBufferGamma(float g) {
    	distanceFilter.setDistanceGamma(g);
    	//load();
    	int originalViewOffsetX = originalViewWidth - (int)originalViewCropRect.left;
		int originalViewOffsetY = originalViewHeight - (int)originalViewCropRect.top;
    	geometryBuffer3d = new GeometryBuffer3D(distanceImage, fov, coordinateSpaceConverter, distanceFilter, originalViewWidth, originalViewHeight, originalViewOffsetX, originalViewOffsetY);
    }
    
	
	
    
	/////////////////////////////////////////////////////////////////////////////////////
	// The mask image is an image reflecting the sky/land pixels
	// land pixels are set to white, sky to black
	BufferedImage getSubstanceMaskImage() {
		return geometryBuffer3d.substanceImage;
	}
	
	
	ArrayList<String> getRenderImageNames(){
		return renderImages.getShortNameList();
	}
	
	
	
	
	public BufferedImage setCurrentRenderImage(String shortName) {
		currentRenderKeyImage = renderImages.getImage(shortName);
		currentRenderKeyImageHasAlpha = ImageProcessing.hasAlpha(currentRenderKeyImage);
		return currentRenderKeyImage;
	}
	
	public void setCurrentRenderImage(int  n) {
		currentRenderKeyImage = renderImages.getImage(n);
		String shortName = renderImages.getShortNameOfItem(n);
		System.out.println("curren render image is " + shortName);
		currentRenderKeyImageHasAlpha = ImageProcessing.hasAlpha(currentRenderKeyImage);
	}

	
	BufferedImage getCurrentRenderImage() {
		return currentRenderKeyImage;
	}
	
	BufferedImage getRenderImage(String shortName) {
		BufferedImage renderImage = renderImages.getImage(shortName);
		return renderImage;
	}
	
	
	void makeRenderImageMenu(SimpleUI ui, int x, int y) {
		ArrayList<String> names = getRenderImageNames();
	    String nameArray[] = new String[names.size()+1];
	    nameArray[0] = "none";
	    int i = 1;
	    for(String name: names) {
	    	nameArray[i++] = name;
	    }
	    ui.addMenu("SceneData View", x, y, nameArray);
	}
	
	
	
	
	
	float getCurrentRender01Value(PVector docSpace) {
		Color rgb = getCurrentRenderColor(docSpace);
		int r = rgb.getRed();
		int g = rgb.getGreen();
		int b = rgb.getBlue();
		return (r+g+b)/765f;
	}
	
	Color getCurrentRenderColor(PVector docSpace) {
		PVector coord = coordinateSpaceConverter.docSpaceToImageCoord(docSpace);
		int packedCol = currentRenderKeyImage.getRGB((int)coord.x, (int)coord.y);
		
		return ImageProcessing.packedIntToColor(packedCol, currentRenderKeyImageHasAlpha);
	}
	
	
	
	boolean isSubstance(PVector docSpace) {
		PVector coord = coordinateSpaceConverter.docSpaceToImageCoord(docSpace);
		int packedCol = geometryBuffer3d.substanceImage.getRGB((int)coord.x, (int)coord.y);
		Color c = ImageProcessing.packedIntToColor(packedCol, true);
		if( c.getRed() > 0) return true;
		return false;
	}
	
	PVector get3DPoint(PVector docSpace) {
		return geometryBuffer3d.docSpaceToWorld3D(docSpace);
	}
	
	float get3DScale(PVector docSpace) {
		return geometryBuffer3d.get3DScale(docSpace);
	}
	
	
	float getDepth(PVector docSpace) {
		return geometryBuffer3d.getDepth(docSpace);
	}
	
	
	float getDepthNormalised(PVector docSpace) {
		return geometryBuffer3d.getDepthNormalised(docSpace);
	}
	
	
	
	float getDistance(PVector docSpace) {
		return geometryBuffer3d.getDistance(docSpace);
	}
	
	

}

///////////////////////////////////////////////////////////////////////////////////
//Given a document of aspect mouseOrganAspect
//and a TargetBuffer buffer of width, height
//produce the following coordinate transforms
// 
class CoordinateSpaceConverter{
	
	int targetWidth;
	int targetHeight;
	float mouseOrganDocAspect;

	public CoordinateSpaceConverter(int renderWidth, int renderHeight,float mouseOrganDocAsp) {
		targetWidth = renderWidth;
		targetHeight = renderHeight;
		
		mouseOrganDocAspect = mouseOrganDocAsp;
	}
	
	

	// for any point in the mouse organ doc space
	// return the image coordinate of the render buffer
	public PVector docSpaceToImageCoord(PVector docSpace) {
		PVector normSpace = docSpaceToNormalizedSpace(docSpace);
		return normalizedSpaceToImageCoord(normSpace);
	}


	// for any image coordinate of the render buffer
	// return the document mouse organ document space. Some will be out of the range 0..1
	
	public PVector renderImageCoordToDocSpace(float x, float y) {

		float dx = MOMaths.norm(x, 0, targetWidth);
		float dy = MOMaths.norm(y, 0, targetHeight);
		if(mouseOrganDocAspect > 1f ) {
			dy /= mouseOrganDocAspect;
		}else {
			dx *= mouseOrganDocAspect;
		}

		return new PVector(dx,dy);
	}

	PVector docSpaceToNormalizedSpace(PVector docSpace) {

		float x = 0;
		float y = 0;
		if(mouseOrganDocAspect > 1f ) {
			x = docSpace.x;
			y = docSpace.y*mouseOrganDocAspect;
		}else {
			x = docSpace.x/mouseOrganDocAspect;
			y = docSpace.y;
		}
		return new PVector(x,y);
	}
	
	PVector normalizedSpaceToDocSpace(PVector normalSpace) {

		float x = 0;
		float y = 0;
		if(mouseOrganDocAspect > 1f ) {
			x = normalSpace.x;
			y = normalSpace.y/mouseOrganDocAspect;
		}else {
			x = normalSpace.x*mouseOrganDocAspect;
			y = normalSpace.y;
		}
		return new PVector(x,y);
	}


	private PVector normalizedSpaceToImageCoord(PVector normSpace) {
		float x = normSpace.x * targetWidth;
		float y = normSpace.y * targetHeight;
		x = MOMaths.constrain(x, 0, targetWidth-1);
		y = MOMaths.constrain(y, 0, targetHeight-1);
		return new PVector(x,y);
	}

	

}

///////////////////////////////////////////////////////////////////////////////////
// This is a particular filter you impose on the distance buffer to skew the distance
// values into the range and population you would like for your image
// It has a complete knock-on effect for all geometry (depth, 3-D locations, normals)

// works by mapping the original value, in the range MIN_ORIG_DIST, MAX_ORIG_DIST, through a floating-point LUT of 


class DistanceBufferFilter{
	Range original_extrema = new Range();
	float zGamma = 1.0f;
	
	void setOriginalExtrema(Range e) {
		original_extrema = e.copy();
		System.out.println("DistanceBufferFilter setoriginalExtrema " + original_extrema.toStr());
	}
	
	void setDistanceGamma(float zbend) {
		
		zGamma = zbend;
	}
	
	float applyFilter(float unfilteredDistance) {
		if(zGamma == 1.0f) return unfilteredDistance;
		
		float normalised = original_extrema.norm(unfilteredDistance);

		// apply your filter here
		//normalised = (float) Math.pow((double)normalised, 0.99999999);
		
		//normalised = 1 - (normalised*normalised);
		normalised = (float)Math.pow(normalised, zGamma);
		
		return original_extrema.lerp(normalised);
	}
}

///////////////////////////////////////////////////////////////////////////////////
// GeometryBuffer3D is initialised with a "distance image" and a vertical FOV
// This is then converted to a depthBuffer of perpendicular distances to the viewing plane
// so you have a distanceBuffer and a depthBuffer, which are slightly different
// The buffers contains -Float.MAX_VAL values which are ignored by normalisation
// which contain the "sky" parts.
//
// 
// For pictorial purposes, you can gamma-bend the distance buffer. The results are stored in the filteredDistanceBuffer.
// If no filter is applied then the filteredDistanceBuffer is the same as the distanceBuffer.
// All depth and other geometric calculations are based on the results of the filteredDistance.
//

class GeometryBuffer3D{
	// substance image is the black/white mask image for substance/sky
	BufferedImage substanceImage;
	
	// the original distance data gathered from the scene, left in its
	// original units. -Float.MAX_VAL is set for "sky"
	private FloatImage distanceBuffer;
	private FloatImage filteredDistanceBuffer;
	
	// the orthogonal distance to the viewing plane in the the range 0..1
	FloatImage depthBuffer;
	
	int width, height;
	
	double verticalFOVover2; // vertical fov
	float distanceCameraToViewingPlane;
	
	int originalViewOffsetX;
	int originalViewOffsetY;
	float originalViewWidthOver2, originalViewHeightOver2;
	
	Range depthBufferExtrema;
	Range distanceBufferExtrema;
	
	
	// document aspect is the aspect of the
	// output compositer render, not the input roi
	float documentAspect;
	CoordinateSpaceConverter coordinateSpaceConverter;
	
	DistanceBufferFilter distanceBufferFilter = new DistanceBufferFilter();
	
	
	public GeometryBuffer3D(FloatImage distanceBuff, float vfov, CoordinateSpaceConverter csc, DistanceBufferFilter dbf, int origViewWidth, int origViewHeight, int origViewOffsetX, int origViewOffsetY) {
		distanceBufferFilter = dbf;
		distanceBuffer = distanceBuff;
		verticalFOVover2 = (vfov/2.0)*(Math.PI/180.0);
		//documentAspect = docAspect;
		
		coordinateSpaceConverter = csc;
		
		width = distanceBuffer.getWidth();
		height = distanceBuffer.getHeight();
		originalViewWidthOver2 = origViewWidth/2f;
		originalViewHeightOver2 = origViewHeight/2f;
		distanceCameraToViewingPlane = (float) ((origViewHeight/2f) / Math.tan(verticalFOVover2));
		
		originalViewOffsetX = origViewOffsetX;
		originalViewOffsetY = origViewOffsetY;
		
		System.out.println(" width heigh of scene data   " + width + " " + height);
		System.out.println(" pixel 3d distanceCameraToViewingPlane   " + distanceCameraToViewingPlane);
		
		
		makeFilteredDistanceBuffer();
		makeDepthAndSubstanceBuffers();
		
	}
	
	
	

	
	void makeFilteredDistanceBuffer() {
		filteredDistanceBuffer = new FloatImage(width,height);
		distanceBufferExtrema = distanceBuffer.getExtrema();
		distanceBufferFilter.setOriginalExtrema(distanceBufferExtrema);
		for(int y = 0; y < height; y++) {
			for(int x = 0; x < width; x++) {
				float rawDistance = distanceBuffer.get(x, y); 
				
				if(rawDistance == -Float.MAX_VALUE) {
					filteredDistanceBuffer.set(x,y, -Float.MAX_VALUE);
					
				}else {
					float filteredDistance = distanceBufferFilter.applyFilter(rawDistance);
					filteredDistanceBuffer.set(x,y, filteredDistance);
				}
			}
		}
	}
	
	private void makeDepthAndSubstanceBuffers() {
		// this makes the depthBuffer - a floatimage containing the perpendicular distances
		// it also contains -1 values for "sky" (infinitely distant)
		depthBufferExtrema = new Range(Float.MAX_VALUE,-Float.MAX_VALUE);
		
		int BLACK = ImageProcessing.packARGB(255, 0, 0, 0);
		int WHITE = ImageProcessing.packARGB(255, 255, 255, 255);
		substanceImage = new BufferedImage(width,height, BufferedImage.TYPE_INT_ARGB);
		
		depthBuffer = new FloatImage(width,height);
		
		for(int y = 0; y < height; y++) {
			for(int x = 0; x < width; x++) {
				
				// this gets dz from the filteredDistanceBuffer
				float dz = filteredDistanceBuffer.get(x, y);
				
				if(dz== -Float.MAX_VALUE) 
					{
					substanceImage.setRGB(x, y, BLACK);
					depthBuffer.set(x, y, -Float.MAX_VALUE);
					}
				else {
					substanceImage.setRGB(x, y, WHITE);
					float depth = distanceBufferToDepthBufferValue( x,  y);
					depthBufferExtrema.addExtremaCandidate(depth);
					depthBuffer.set(x, y, depth);
					}
			}
		}
		
		System.out.println("depth buffer extrema are " + depthBufferExtrema.limit1 + " " + depthBufferExtrema.limit2);
		
	}
	
	
	
	
	//
	float get3DScale(PVector docPt) {
		// Returns the document-space distance, that is the unit 3D distance (1.0) at that document space point in the 3D scene.
		// so for points further away the distance will be shorter etc.
		// Used for scaling things accurately against the scene
		PVector this3DPoint = docSpaceToWorld3D(docPt);
		PVector unitDistance = this3DPoint.copy();
		unitDistance.y = unitDistance.y + 1;
		PVector shiftedDocPt = world3DToDocSpace(unitDistance);
		return docPt.dist(shiftedDocPt);
	}
	
	
	PVector docSpaceToWorld3D(PVector docSpace) {
		// returns the 3D point at a point in the scene using the original
		// distance values
		PVector vIntoScene = getVectorIntoScene(docSpace);
		vIntoScene.normalize();
		float d = getDistance(docSpace);
		return  PVector.mult(vIntoScene, d);
	}
	
    
	PVector world3DToDocSpace(PVector world3dPt) {
		// given an arbitrary 3D point in world space, return where that point would project onto
		// in doc space
		float z = world3dPt.z;
		PVector divByZ = new PVector(world3dPt.x/z, world3dPt.y/z, 1f);
		PVector pointOnVPEyeSpace = PVector.mult(divByZ, distanceCameraToViewingPlane);
		return eyeSpaceWindowCoordToDocSpace(pointOnVPEyeSpace);
	}
	
	float getDistance(PVector docSpace) {
		// returns the filtered distance
		PVector coord = coordinateSpaceConverter.docSpaceToImageCoord(docSpace);
		return filteredDistanceBuffer.getPixelBilin(coord.x, coord.y); 
	}
	
	
	float getDistance(float x, float y) {
		// returns the filtered distance
		// using actual buffer pixel coords
		return filteredDistanceBuffer.getPixelBilin(x, y); 
	}
	
	float getUnfilteredDistance(PVector docSpace) {
		PVector coord = coordinateSpaceConverter.docSpaceToImageCoord(docSpace);
		return distanceBuffer.getPixelBilin(coord.x, coord.y); 
	}

	float getDepth(PVector docSpace) {
		PVector coord = coordinateSpaceConverter.docSpaceToImageCoord(docSpace);
		float d =  depthBuffer.getPixelBilin(coord.x, coord.y); 
		return d;
	}
	
	float getDepthNormalised(PVector docSpace) {
		float d = getDepth( docSpace);
		return depthBufferExtrema.norm(d);
	}
	
	
	
	///////////////////////////////////////////////////////////////////
	// private methods
	//
	
	
	
	
	PVector docSpaceToEyeSpaceWindowCoord(PVector docSpace) {
		PVector imgeCoord = coordinateSpaceConverter.docSpaceToImageCoord(docSpace);
		
		float originalViewImageCoordX = imgeCoord.x + originalViewOffsetX;
		float originalViewImageCoordY = imgeCoord.y + originalViewOffsetY;
		
		float wx = (originalViewImageCoordX-originalViewWidthOver2);
		float wy = (originalViewImageCoordY-originalViewHeightOver2);
		return new PVector(wx,wy);
	}
	
	PVector eyeSpaceWindowCoordToDocSpace(PVector eyeSpaceWinCoord) {
		
		float eyeSpaceWinCoordXOffset = eyeSpaceWinCoord.x - originalViewOffsetX;
		float eyeSpaceWinCoordYOffset = eyeSpaceWinCoord.y - originalViewOffsetY;
		
		float wx = (eyeSpaceWinCoordXOffset+originalViewWidthOver2);
		float wy = (eyeSpaceWinCoordYOffset+originalViewHeightOver2);
		return coordinateSpaceConverter.renderImageCoordToDocSpace(wx,wy);
	}
	
	PVector getVectorIntoScene(PVector docSpace) {
		//returns the vector into the scene from the position (0,0,0)
		PVector eyeCoord =  docSpaceToEyeSpaceWindowCoord(docSpace);
		eyeCoord.z = distanceCameraToViewingPlane;
		return eyeCoord;
	}
	
	float getCosineVectorIntoScene(PVector docSpace) {
		PVector vIntoScene = getVectorIntoScene(docSpace);
		vIntoScene.normalize();
		PVector camVector = new PVector(0f,0f,1);
		return vIntoScene.dot(camVector);
	}
	

	// calculates the orthogonal depth at the x,y of the filtered distance buffer
	private float distanceBufferToDepthBufferValue(int x, int y) {
		PVector docSpace = coordinateSpaceConverter.renderImageCoordToDocSpace(x,y);
		float cos = getCosineVectorIntoScene( docSpace);
		float d = getDistance(x,y);
		return d*cos;
	}

	//float sqr(float a) { return a*a;}
	
	
	
	
	
	
	
	
	
}







