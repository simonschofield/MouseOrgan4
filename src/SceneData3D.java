import java.awt.Color;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Scanner;

///////////////////////////////////////////////////////////////////////////////
// Scene3D and DepthBuffer data image dimensions are generated by another package
// You will probably have them roughly the same aspect as your Main Document Image.
// To keep the interface working betweenthe two sets of dimensions, access to
// Scene3D data is using a converter which first converts MO Doc space
// into Normalized space (both x and y in the range 0..1)
//
// To keep the interface easy within the MouseOrgan user session, Document Space
// (0..1 in the longest edge, 0.. <1 in the shorter edge of the Mouse Organ Document)
// is used, then conveted to Normalized space for further use, hence you initialise the 
// SceneDtat3D class with the Mouse Organ Document Aspect

public class SceneData3D {
	// path to the specified input scenedata folder
	String directoryPath;
	
	
	// view data from the original 3D scene
	PVector cameraPosition;
	PVector cameraLookat;
	Rect theROI;
	
	CoordinateSpaceConverter coordinateSpaceConverter;
	
	// document aspect is the aspect of the
	// output compositer render, not the input roi
	float mouseOrganDocAspect;
	
	// the with and height of the renders and depth images (should all be the same)
	int renderWidth;
	int renderHeight;
	
	// this reads in and contains all the png files within the input folder
	DirectoryImageGroup renderImages;
	BufferedImage currentRenderKeyImage;
	boolean currentRenderKeyImageHasAlpha;
	
	// depth stuff. The depthImage is normalised to 0..1 after loading
	// but the original min and max depth are kept so the
	// original depths can be recalculated
	
	Range originalDepthExtrema;
	GeometryBuffer3D geometryBuffer3d;
	DistanceBufferFilter distanceFilter;
	
	
	public SceneData3D(float docAspect, DistanceBufferFilter dFilter) {
		mouseOrganDocAspect = docAspect;
		distanceFilter = dFilter;
	}
	
	

	public void load(String targetDirectory) {

		directoryPath = targetDirectory;
		load();
	}
		
    public void load(){
		renderImages = new DirectoryImageGroup(directoryPath);
		renderImages.loadContent();
		
		// this is a "distance" image, it is converted to a proper depth image
		// in the DepthBuffer object
		FloatImage distanceImage = new FloatImage(directoryPath + "\\distance.data");

		renderWidth = distanceImage.getWidth();
		renderHeight = distanceImage.getHeight();

		ArrayList<String> strList = readTextFile(directoryPath + "\\view.txt");
		String fovString = strList.get(2);
		float fov = Float.parseFloat(fovString);
		String topleftSt = strList.get(5);
		String botRighSt = strList.get(6);
		
		PVector topLeftV = new PVector();
		topLeftV.fromString(topleftSt);
		
		PVector botRighV = new PVector();
		botRighV.fromString(botRighSt);
		
		theROI = new Rect(topLeftV,botRighV);
		
		
		System.out.println("roil loaded is " + theROI.toStr() + " FOV is " + fov);
		coordinateSpaceConverter = new CoordinateSpaceConverter(renderWidth,renderHeight, theROI, mouseOrganDocAspect);
		
		
		geometryBuffer3d = new GeometryBuffer3D(distanceImage, fov, coordinateSpaceConverter, distanceFilter);
		
		setCurrentRenderImage(0);
	}
	
	
    void useFilteredDistance(boolean use) {
    	geometryBuffer3d.useFilteredDistance(use);
	}
	
	/////////////////////////////////////////////////////////////////////////////////////
	// The mask image is an image reflecting the sky/land pixels
	// land pixels are set to white, sky to black
	BufferedImage getSubstanceMaskImage() {
		return geometryBuffer3d.substanceImage;
	}
	
	
	ArrayList<String> getRenderImageNames(){
		return renderImages.getShortNameList();
	}
	
	
	
	
	public void setCurrentRenderImage(String shortName) {
		currentRenderKeyImage = renderImages.getImage(shortName);
		currentRenderKeyImageHasAlpha = ImageProcessing.hasAlpha(currentRenderKeyImage);
	}
	
	public void setCurrentRenderImage(int  n) {
		currentRenderKeyImage = renderImages.getImage(n);
		String shortName = renderImages.getShortNameOfItem(n);
		System.out.println("curren render image is " + shortName);
		currentRenderKeyImageHasAlpha = ImageProcessing.hasAlpha(currentRenderKeyImage);
	}

	
	BufferedImage getCurrentRenderImage() {
		return currentRenderKeyImage;
	}
	
	BufferedImage getRenderImageROI(String shortName) {
		BufferedImage renderImage = renderImages.getImage(shortName);
		int x1 = (int)theROI.left;
		int y1 = (int)theROI.top;
		int w = (int)theROI.getWidth();
		int h = (int)theROI.getHeight();
		//System.out.println("getRenderImageROI total render size is  " + renderImage.getWidth() + " " + renderImage.getHeight());
		//System.out.println("getRenderImageROI ROI is " + theROI.toStr() + " w/h " + theROI.getWidth() + " " + theROI.getHeight());
		//System.out.println("getRenderImageROI coords " + shortName);
		
		BufferedImage roiImage = renderImage.getSubimage(x1, y1, w, h);
		
		return roiImage;
	}
	
	
	void makeRenderImageMenu(SimpleUI ui, int x, int y) {
		ArrayList<String> names = getRenderImageNames();
	    String nameArray[] = new String[names.size()+1];
	    nameArray[0] = "none";
	    int i = 1;
	    for(String name: names) {
	    	nameArray[i++] = name;
	    }
	    ui.addMenu("SceneData View", x, y, nameArray);
	}
	
	
	
	
	
	float getCurrentRender01Value(PVector docSpace) {
		Color rgb = getCurrentRenderColor(docSpace);
		int r = rgb.getRed();
		int g = rgb.getGreen();
		int b = rgb.getBlue();
		return (r+g+b)/765f;
	}
	
	Color getCurrentRenderColor(PVector docSpace) {
		PVector coord = coordinateSpaceConverter.docSpaceToImageCoord(docSpace);
		int packedCol = currentRenderKeyImage.getRGB((int)coord.x, (int)coord.y);
		
		return ImageProcessing.packedIntToColor(packedCol, currentRenderKeyImageHasAlpha);
	}
	
	Rect getROI() {
		return theROI;
	}
	
	boolean isSubstance(PVector docSpace) {
		PVector coord = coordinateSpaceConverter.docSpaceToImageCoord(docSpace);
		int packedCol = geometryBuffer3d.substanceImage.getRGB((int)coord.x, (int)coord.y);
		Color c = ImageProcessing.packedIntToColor(packedCol, true);
		if( c.getRed() > 0) return true;
		return false;
	}
	
	PVector get3DPoint(PVector docSpace) {
		return geometryBuffer3d.docSpaceToWorld3D(docSpace);
	}
	
	float get3DScale(PVector docSpace) {
		return geometryBuffer3d.get3DScale(docSpace);
	}
	
	
	float getDepth(PVector docSpace) {
		return geometryBuffer3d.getDepth(docSpace);
	}
	
	
	float getDepthNormalised(PVector docSpace) {
		return geometryBuffer3d.getDepthNormalised(docSpace);
	}
	
	float getROIDepthNormalised(PVector docSpace) {
		return geometryBuffer3d.getROIDepthNormalised(docSpace);
	}
	
	float getDistance(PVector docSpace) {
		return geometryBuffer3d.getDistance(docSpace);
	}
	
	
	ArrayList<String> readTextFile(String pathAndName) {
		ArrayList<String> stListOut = new ArrayList<String>();
		File myObj = new File(pathAndName);
		try{
	      Scanner myReader = new Scanner(myObj);
	      while (myReader.hasNextLine()) {
	        String data = myReader.nextLine();
	        stListOut.add(data);
	        System.out.println(data);
	      }
	      myReader.close();
		}catch (IOException e) {}
		return stListOut;
	}
	



}

///////////////////////////////////////////////////////////////////////////////////
//Given a document of aspect mouseOrganAspect
//and a TargetBuffer buffer of width, height, which may be using a ROI to map to
//produce the following coordinate transforms
// 
class CoordinateSpaceConverter{
	Rect targetROI;
	int targetWidth;
	int targetHeight;
	float mouseOrganDocAspect;

	public CoordinateSpaceConverter(int renderWidth, int renderHeight,float mouseOrganDocAsp) {
		targetWidth = renderWidth;
		targetHeight = renderHeight;
		targetROI = new Rect(0,0,renderWidth,renderHeight);
		mouseOrganDocAspect = mouseOrganDocAsp;
	}
	
	public CoordinateSpaceConverter(int renderWidth, int renderHeight, Rect theROI, float mouseOrganDocAsp) {
		targetWidth = renderWidth;
		targetHeight = renderHeight;
		targetROI = theROI.copy();
		mouseOrganDocAspect = mouseOrganDocAsp;
	}

	// for any point in the mouse organ doc space
	// return the image coordinate of the render buffer
	public PVector docSpaceToImageCoord(PVector docSpace) {
		PVector normSpace = docSpaceToNormalizedSpace(docSpace);
		return normalizedSpaceToImageCoord(normSpace);
	}


	// for any image coordinate of the render buffer
	// return the document mouse organ document space. Some will be out of the range 0..1
	
	public PVector renderImageCoordToDocSpace(float x, float y) {

		float dx = MOMaths.norm(x, targetROI.left, targetROI.right);
		float dy = MOMaths.norm(y, targetROI.top,targetROI.bottom);
		if(mouseOrganDocAspect > 1f ) {
			dy /= mouseOrganDocAspect;
		}else {
			dx *= mouseOrganDocAspect;
		}

		return new PVector(dx,dy);
	}

	private PVector docSpaceToNormalizedSpace(PVector docSpace) {

		float x = 0;
		float y = 0;
		if(mouseOrganDocAspect > 1f ) {
			x = docSpace.x;
			y = docSpace.y*mouseOrganDocAspect;
		}else {
			x = docSpace.x/mouseOrganDocAspect;
			y = docSpace.y;
		}
		return new PVector(x,y);
	}
	
	PVector normalizedSpaceToDocSpace(PVector normalSpace) {

		float x = 0;
		float y = 0;
		if(mouseOrganDocAspect > 1f ) {
			x = normalSpace.x;
			y = normalSpace.y/mouseOrganDocAspect;
		}else {
			x = normalSpace.x*mouseOrganDocAspect;
			y = normalSpace.y;
		}
		return new PVector(x,y);
	}


	private PVector normalizedSpaceToImageCoord(PVector normSpace) {
		float x = MOMaths.lerp(normSpace.x, targetROI.left,targetROI.right);
		float y = MOMaths.lerp(normSpace.y, targetROI.top,targetROI.bottom);
		x = MOMaths.constrain(x, 0, targetWidth-1);
		y = MOMaths.constrain(y, 0, targetHeight-1);
		return new PVector(x,y);
	}

	boolean isInROI(int x, int y) {
		if( targetROI.isPointInside(x, y)) return true;
		return false;
	}

}

///////////////////////////////////////////////////////////////////////////////////
// This is a particular filter you impose on the distance buffer to skew the distance
// values into the range and population you would like for your image
// It has a complete knock-on effect for all geometry (depth, 3-D locations, normals)

// works by mapping the original value, in the range MIN_ORIG_DIST, MAX_ORIG_DIST, through a floating-point LUT of 


class DistanceBufferFilter{
	Range original_extrema = new Range();
	float zGamma = 1.7f;
	
	void setOriginalExtrema(Range e) {
		original_extrema = e.copy();
	}
	
	void setDistanceGamma(float zbend) {
		
		zGamma = zbend;
	}
	
	float applyFilter(float unfilteredDistance) {
		float normalised = original_extrema.norm(unfilteredDistance);
		
		// apply your filter here
		//normalised = (float) Math.pow((double)normalised, 0.99999999);
		
		//normalised = 1 - (normalised*normalised);
		normalised = (float)Math.pow(normalised, zGamma);
		
		return original_extrema.lerp(normalised);
	}
}

///////////////////////////////////////////////////////////////////////////////////
// GeometryBuffer3D is initialised with a "distance image" and a vertical FOV
// This is then converted to a depthBuffer of perpendicular distances to the viewing plane
// so you have a distanceBuffer and a depthBuffer, which are slightly different
// The buffers contains -Float.MAX_VAL values which are ignored by normalisation
// which contain the "sky" parts.

class GeometryBuffer3D{
	// substance image is the black/white mask image for substance/sky
	BufferedImage substanceImage;
	
	// the original distance data gathered from the scene, left in its
	// original units. -Float.MAX_VAL is set for "sky"
	private FloatImage distanceBuffer;
	private FloatImage filteredDistanceBuffer;
	
	// the orthogonal distance to the viewing plane in the the range 0..1
	FloatImage depthBuffer;
	
	int width, height;
	float widthOver2, heightOver2;
	double verticalFOVover2; // vertical fov
	float distanceCameraToViewingPlane;
	
	Range wholeDepthImageExtrema;
	Range roiExtrema;
	
	// document aspect is the aspect of the
	// output compositer render, not the input roi
	float documentAspect;
	CoordinateSpaceConverter coordinateSpaceConverter;
	
	DistanceBufferFilter distanceBufferFilter = new DistanceBufferFilter();
	boolean useFilteredDistance = true;
	
	public GeometryBuffer3D(FloatImage distanceBuff, float vfov, CoordinateSpaceConverter csc, DistanceBufferFilter dbf) {
		distanceBufferFilter = dbf;
		distanceBuffer = distanceBuff;
		verticalFOVover2 = (vfov/2.0)*(Math.PI/180.0);
		//documentAspect = docAspect;
		
		coordinateSpaceConverter = csc;
		
		width = distanceBuffer.getWidth();
		height = distanceBuffer.getHeight();
		widthOver2 = width/2f;
		heightOver2 = height/2f;
		distanceCameraToViewingPlane = (float) ((height/2f) / Math.tan(verticalFOVover2));
		System.out.println(" width heigh of scene data   " + width + " " + height);
		System.out.println(" pixel 3d distanceCameraToViewingPlane   " + distanceCameraToViewingPlane);
		
		
		makeFilteredDistanceBuffer();
		makeDepthBuffer();
		
	}

	void useFilteredDistance(boolean use) {
		useFilteredDistance = use;
	}
	
	void makeFilteredDistanceBuffer() {
		filteredDistanceBuffer = new FloatImage(width,height);
		distanceBufferFilter.setOriginalExtrema(distanceBuffer.getExtrema());
		for(int y = 0; y < height; y++) {
			for(int x = 0; x < width; x++) {
				float rawDistance = distanceBuffer.getPixelBilin(x, y); 
				float filteredDistance = distanceBufferFilter.applyFilter(rawDistance);
				filteredDistanceBuffer.set(x,y, filteredDistance);
			}
		}
	}
	
	//
	float get3DScale(PVector docPt) {
		// Returns the document-space distance, that is the unit 3D distance (1.0) at that document space point in the 3D scene.
		// so for points further away the distance will be shorter etc.
		// Used for scaling things accurately against the scene
		PVector this3DPoint = docSpaceToWorld3D(docPt);
		PVector unitDistance = this3DPoint.copy();
		unitDistance.y = unitDistance.y + 1;
		PVector shiftedDocPt = world3DToDocSpace(unitDistance);
		return docPt.dist(shiftedDocPt);
	}
	
	
	PVector docSpaceToWorld3D(PVector docSpace) {
		// returns the 3D point at a point in the scene using the original
		// distance values
		PVector vIntoScene = getVectorIntoScene(docSpace);
		vIntoScene.normalize();
		float d = getDistance(docSpace);
		return  PVector.mult(vIntoScene, d);
	}
	
    
	PVector world3DToDocSpace(PVector world3dPt) {
		// given an arbitrary 3D point in world space, return where that point would project onto
		// in doc space
		float z = world3dPt.z;
		PVector divByZ = new PVector(world3dPt.x/z, world3dPt.y/z, 1f);
		PVector pointOnVPEyeSpace = PVector.mult(divByZ, distanceCameraToViewingPlane);
		return eyeSpaceWindowCoordToDocSpace(pointOnVPEyeSpace);
	}
	
	float getDistance(PVector docSpace) {
		PVector coord = coordinateSpaceConverter.docSpaceToImageCoord(docSpace);
		float d =  getDistance(coord.x, coord.y);
		if(d < 0) return -1f;
		return d;
	}
	
	
	float getDistance(float x, float y) {
		// using actual buffer pixel coords
		if(useFilteredDistance) return filteredDistanceBuffer.getPixelBilin(x, y); 
		return distanceBuffer.getPixelBilin(x, y); 
	}
	

	float getDepth(PVector docSpace) {
		PVector coord = coordinateSpaceConverter.docSpaceToImageCoord(docSpace);
		float d =  depthBuffer.getPixelBilin(coord.x, coord.y); 
		return d;
	}
	
	float getDepthNormalised(PVector docSpace) {
		float d = getDepth( docSpace);
		if(d == -1f) return -1f;
		return wholeDepthImageExtrema.norm(d);
	}
	
	float getROIDepthNormalised(PVector docSpace){
		// not sure how useful this is, as we are probably still going to needs depths outside of the roi
		float d = getDepth( docSpace);
		if(d == -1f) return -1f;
		return roiExtrema.norm(d);
	}
	
	///////////////////////////////////////////////////////////////////
	// private methods
	//
	
	
	
	
	PVector docSpaceToEyeSpaceWindowCoord(PVector docSpace) {
		PVector imgeCoord = coordinateSpaceConverter.docSpaceToImageCoord(docSpace);
		float wx = (imgeCoord.x-widthOver2);
		float wy = (imgeCoord.y-heightOver2);
		return new PVector(wx,wy);
	}
	
	PVector eyeSpaceWindowCoordToDocSpace(PVector eyeSpaceWinCoord) {
		float wx = (eyeSpaceWinCoord.x+widthOver2);
		float wy = (eyeSpaceWinCoord.y+heightOver2);
		return coordinateSpaceConverter.renderImageCoordToDocSpace(wx,wy);
	}
	
	PVector getVectorIntoScene(PVector docSpace) {
		PVector eyeCoord =  docSpaceToEyeSpaceWindowCoord(docSpace);
		eyeCoord.z = distanceCameraToViewingPlane;
		return eyeCoord;
	}
	
	float getCosineVectorIntoScene(PVector docSpace) {
		PVector vIntoScene = getVectorIntoScene(docSpace);
		vIntoScene.normalize();
		PVector camVector = new PVector(0f,0f,1);
		return vIntoScene.dot(camVector);
	}
	

	// used for straight conversion between the two
	private float distanceBufferToDepthBufferValue(int x, int y) {
		PVector docSpace = coordinateSpaceConverter.renderImageCoordToDocSpace(x,y);
		float cos = getCosineVectorIntoScene( docSpace);
		float d = getDistance(x,y);
		return d*cos;
	}

	float sqr(float a) { return a*a;}
	
	private void makeDepthBuffer() {
		// this makes the depthBuffer - a floatimage containing the perpendicular distances
		// it also contains -1 values for "sky" (infinitely distant)
		wholeDepthImageExtrema = new Range(100000,-100000);
		roiExtrema = new Range(100000,-100000);
		int BLACK = ImageProcessing.packARGB(255, 0, 0, 0);
		int WHITE = ImageProcessing.packARGB(255, 255, 255, 255);
		substanceImage = new BufferedImage(width,height, BufferedImage.TYPE_INT_ARGB);
		
		depthBuffer = new FloatImage(width,height);
		for(int y = 0; y < height; y++) {
			for(int x = 0; x < width; x++) {
				
				// this gets dz from the filteredDistanceBuffer
				float dz = getDistance(x,y);
				
				if(dz == -1) 
					{
					substanceImage.setRGB(x, y, BLACK);
					distanceBuffer.set(x, y, -Float.MAX_VALUE);
					filteredDistanceBuffer.set(x, y, -Float.MAX_VALUE);
					
					depthBuffer.set(x, y, -Float.MAX_VALUE);
					
					}
				else {

					substanceImage.setRGB(x, y, WHITE);
					float depth = distanceBufferToDepthBufferValue( x,  y);
					
		
					if( coordinateSpaceConverter.isInROI(x,y) ) roiExtrema.addExtremaCandidate(depth);
					wholeDepthImageExtrema.addExtremaCandidate(depth);
					depthBuffer.set(x, y, depth);
					}
			}
		}
		
		depthBuffer.setMaskValue(-Float.MAX_VALUE, true);
		distanceBuffer.setMaskValue(-Float.MAX_VALUE, true);
		filteredDistanceBuffer.setMaskValue(-Float.MAX_VALUE, true);
		
		System.out.println("depth buffer extrema are" + wholeDepthImageExtrema.limit1 + " " + wholeDepthImageExtrema.limit2);
		System.out.println("ROI extrema are" + roiExtrema.limit1 + " " + roiExtrema.limit2);
	}
	
	
	
	
	
	
	
	
}







