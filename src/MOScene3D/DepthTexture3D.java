package MOScene3D;


import java.awt.image.BufferedImage;
import java.awt.image.WritableRaster;

import MOImage.FloatImage;
import MOImage.ImageProcessing;
import MOMaths.PVector;
import MOMaths.Range;


/////////////////////////////////////////////////////////////////////////////////////////////
// Contains a depth texture generated by a render from a MOuseorgan session
// A depth texture can either be a 16Bit Gray scale image, produced as a mask, or a full float image
// 
// The angle of view has to be hand enter at the moment. This is calculated in the SceneDta3D taking inot consideration the 
// original FOV, then the initial crop on this made in the SceneData3D, and then the ROI crop made in the MouseOrgan
public class DepthTexture3D {
	Range originalDepthExtrema;
	float renderVerticalFOVOver2;
	public GeometryBuffer3D geometryBuffer3D;
	
	public DepthTexture3D(BufferedImage gray16BitImg, float angleOfView, float depthExtremaNear, float depthExtremaFar){
		
		
		renderVerticalFOVOver2 = angleOfView;
		originalDepthExtrema = new Range(depthExtremaNear, depthExtremaFar);
		
		
		
		if(gray16BitImg.getType() != BufferedImage.TYPE_USHORT_GRAY) {
			System.out.println("DepthTexture3D :: source iamge is not USHORT_GRAY");
			return;
		}
		
		
		FloatImage depthData = convert16BitGrayToFloatImage(gray16BitImg);
		
		// need to convert depth to distance here
		
		geometryBuffer3D = new GeometryBuffer3D(depthData,angleOfView);
	}
	
	public int getWidth() {
		return geometryBuffer3D.width;
	}
	
	public int getHeight() {
		return geometryBuffer3D.height;
	}
	
	public boolean isSubstance(PVector docSpace) {
		return geometryBuffer3D.isSubstance(docSpace);
	}

	public PVector get3DSurfacePoint(PVector docSpace) {
		return geometryBuffer3D.docSpaceToWorld3D(docSpace);
	}
	
	public PVector get3DSurfacePoint(int x, int y) {
		PVector docSpace = geometryBuffer3D.bufferSpaceToDocSpace(x,y);
		return geometryBuffer3D.docSpaceToWorld3D(docSpace);
	}
	
	
	public PVector get3DVolumePoint(PVector docSpace, float normDepth) {
		float realDistance = geometryBuffer3D.normalisedDepthToRealDepth(normDepth);
		return geometryBuffer3D.docSpaceToWorld3D( docSpace, realDistance);
	}
	
	public float getDistance(PVector docSpace) {
		
		return geometryBuffer3D.getDistance(docSpace);
	}
	
	public float getDepth(PVector docSpace) {
		
		return geometryBuffer3D.getDepth(docSpace);
	}
	
	
	public GeometryBuffer3D getGeometryBuffer3D() {
		return geometryBuffer3D;
	}
	
	
	
	
	
	private FloatImage convert16BitGrayToFloatImage(BufferedImage gray16BitImg) {
		
		
		
		int width = gray16BitImg.getWidth();
		int height = gray16BitImg.getHeight();
		WritableRaster gray16BitImageData = gray16BitImg.getRaster();
		
		FloatImage floatImage = new FloatImage(width,height);
		
		for(int y = 0; y < height; y++) {
			for(int x = 0; x < width; x++) {
				
			
				float gray16BitPixelValueF = gray16BitImageData.getSample(x, y, 0)/65535f;
				if(gray16BitPixelValueF==0) {
					floatImage.set(x, y, -Float.MAX_VALUE);// is turned into no-substance in the GeometryBuffer
				} else {
					float d = originalDepthExtrema.lerp(gray16BitPixelValueF);
					floatImage.set(x, y, d);
				}
				
			}
		}
		return floatImage;
	}
	


	
	
	
}
