package MOScene3D;



import java.awt.Color;
import java.awt.image.BufferedImage;
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;

import MOImage.ConvolutionFilter;
import MOImage.FloatImage;
import MOImage.ImageProcessing;
import MOImage.KeyImageSampler;
import MOImage.MOPackedColor;
import MOImageCollections.DirectoryFileNameScanner;
import MOImageCollections.ImageAssetGroup;

import MOMaths.PVector;
import MOMaths.Range;
import MOMaths.Ray3D;
import MOMaths.Rect;
//import MOSprite.SpriteSeed;
import MOUtils.GlobalSettings;
import MOUtils.ImageCoordinateSystem;
import MOUtils.ImageDimensions;
import MOUtils.KeyValuePairList;
import MOUtils.MOStringUtils;
///////////////////////////////////////////////////////////////////////
//
// SceneData3D provides a wrapper class for data exported from the 3D viewing application.
// The data is 1/ a Depth Buffer, read into an internal depthBuffer3D class
// 2/ A set of texture maps. Textures and the Depth buffer have the same dimensions.
// The class also utilises a ROI manager to convert coordinates from SubROI space to Master space
// and vice versa. The document space for the master render and the internal Depth and Textures buffers are the same.  finally accessed using the master do space
// So the master render has to be the same aspect as the SceneData. This is enabled through the createROIManager(int masterRenderWidth) method
// that returns a ROI manager with the correct master render sizes set up already.
// 
//
//
public class SceneData3D {
	///////////////////////////////////////////////////////////////////////
	// path to the specified scenedata folder
	String directoryPath;

	///////////////////////////////////////////////////////////////////////
	// this reads in and contains all the png files within the input folder
	ImageAssetGroup textureMapImages;
	BufferedImage currentTextureMapImage;
	boolean currentRenderKeyImageHasAlpha;

	///////////////////////////////////////////////////////////////////////
	// Depth Buffer and Eye point calculations are made using the Geometry Buffer
	public DepthBuffer3D depthBuffer3d;

	///////////////////////////////////////////////////////////////////////
	// The roi manager should be generated by the this class for the session using
	// createROIManager(int masterRenderWidth). This sets the master rect to the exact aspect of the
	// scene data.
	private ROIManager roiManager;

	

	public SceneData3D(String targetDirectory) {
		directoryPath = targetDirectory;
		FloatImage depthImage = new FloatImage(directoryPath + "\\depth.data");

		float cameraDistToVP = getCameraDistToVPFromFile(directoryPath + "\\cameraDistance.csv");

		depthBuffer3d = new DepthBuffer3D(depthImage, cameraDistToVP);
		
		// create a default ROIManager. This will probably be user-specified later
		roiManager = createROIManager(3000);
		
		
		GlobalSettings.setSceneData3D(this);
		
	}

	
	
	public void loadTexturemaps(String[] include) {
		
		include = MOStringUtils.addToStringList(include, "blank");

		DirectoryFileNameScanner dfns = new DirectoryFileNameScanner(directoryPath, "png");
		dfns.keep(include);
		
		int num = dfns.getNumFiles();
		System.out.println("SceneData3D is loading " + num + " texturemaps");
		dfns.printToConsoleShortFileNames();
		textureMapImages = new ImageAssetGroup();
		textureMapImages.setDirectoryFileNameScanner(dfns);
		textureMapImages.loadImages();
		setCurrentRenderImage(0);
		
	}
	
	public ROIManager createROIManager(int masterRenderWidth) {
		int renderheight = (int) (masterRenderWidth/this.getAspect());
		roiManager = new ROIManager(masterRenderWidth, renderheight);
		return roiManager;
	}
	
	
	public ImageDimensions getImageDimensions() {
		return new ImageDimensions(depthBuffer3d.width, depthBuffer3d.height);
		
	}
	
	public float getAspect() {
		return depthBuffer3d.width/(float)depthBuffer3d.height;
	}

	private float getCameraDistToVPFromFile(String fileAndPath) {
		// there should be a file in the SceneData called "cameraDistance.csv" exported from
		// TerrainMaker v1_2
		float camDist = 0;
		try {
			BufferedReader csvReader = new BufferedReader(new FileReader(fileAndPath));
			String row;
			while ((row = csvReader.readLine()) != null) {
				KeyValuePairList kvlist = new KeyValuePairList();
				kvlist.ingestCSVLine(row);
				camDist = kvlist.getFloat("CAMDIST_TO_VP");
			}
			csvReader.close();
		} catch (Exception e) {
			System.out.println("SpriteSeedBatch.loadSeedsAsCSV: csv reader failed - " + fileAndPath + e);
		}
		return camDist;
	}

	

	public Rect getROIRect() {
		return roiManager.getCurrentROIDocRect();
	}

	private ImageCoordinateSystem getDepthBufferKeyImageSampler() {
		return depthBuffer3d.depthBufferCoordinateSystem;
	}
	
	

	/////////////////////////////////////////////////////////////////////////////////////
	// The mask image is an image reflecting the sky/land pixels
	// land pixels are set to white, sky to black

	public ArrayList<String> getRenderImageNames() {
		return textureMapImages.getImageAssetNamesList();
	}

	public BufferedImage setCurrentRenderImage(String shortName) {
		currentTextureMapImage = textureMapImages.getImage(shortName);
		currentRenderKeyImageHasAlpha = ImageProcessing.hasAlpha(currentTextureMapImage);
		return currentTextureMapImage;
	}

	public void setCurrentRenderImage(int n) {
		currentTextureMapImage = textureMapImages.getImage(n);
		String shortName = textureMapImages.getImageAssetName(n);
		System.out.println("curren render image is " + shortName);
		currentRenderKeyImageHasAlpha = ImageProcessing.hasAlpha(currentTextureMapImage);
	}

	////////////////////////////////////////////////////////////////
	//
	// get images
	//
	public BufferedImage getSubstanceMaskImage(boolean cropToRoi) {
		if (cropToRoi)
			return cropToROI(depthBuffer3d.substanceImage);
		return depthBuffer3d.substanceImage;
	}

	public BufferedImage getCurrentRenderImage(boolean cropToRoi) {
		if (cropToRoi)
			return cropToROI(currentTextureMapImage);
		return currentTextureMapImage;
	}

	public BufferedImage getRenderImage(String shortName, boolean cropToRoi) {
		BufferedImage renderImage = textureMapImages.getImage(shortName);
		if (cropToRoi)
			return cropToROI(renderImage);
		return renderImage;
	}

	////////////////////////////////////////////////////////////////
	//
	// when using the ROI, you may wish to see the portion of the render in the SceneData texture collection
	// This method crops the image accordingly

	BufferedImage cropToROI(BufferedImage uncropped) {
		// returns the roi cropped image from whatever function
		// System.out.println("cropping to roi rect " + roiRect.toStr());
		Rect currentROIDocSpaceRect = roiManager.getCurrentROIDocRect();
		Rect masterDocSpaceRect = roiManager.getMasterDocumentRect();
		// this needs to be normalised within the master rect
		PVector topLeft = masterDocSpaceRect.norm(   currentROIDocSpaceRect.getTopLeft()   );
		PVector bottomRight = masterDocSpaceRect.norm(   currentROIDocSpaceRect.getBottomRight()   );
		Rect cropRect = new Rect(topLeft, bottomRight);
		//System.out.println("warning using untested cropToROI in scenedata class");
		return ImageProcessing.cropImageWithNormalisedRect(uncropped, cropRect);
	}

	//////////////////////////////////////////////////////////////////
	// Converting from LocalROIDocSpace to MasterDocSpace
	// When this method is used, you assume that the local ROI is in-play as the current document space, hence
	// you can use the GlobalSettings coordinate space conversions
	// IN the V2 version, the MasterRect is stored as a documentSpace rect, and the
	// ROIRect is stored as a wholly contained, sub-rect of the masterRect. Therefore conversion of point localDocPoint in localROIDocSpace to
	// the MasterDocSpace is as follows
	// localNormalised = GlobalSettings.getTheDocumentCoordSystem().docSpaceToNormalisedSpace(roiLocalDocSpace)
	// masterDocSpace = ROIRect.interpolate(localNormalised)
	
	//
	public PVector subROIDocSpaceToMasterDocSpace(PVector roiLocalDocSpace) {

			return roiManager.subROIDocSpaceToMasterDocSpace(roiLocalDocSpace);
	}

	///////////////////////////////////////////////////////////////
	// less used than above. If you happen to have calculated anything in Master Doc
	// space, and want to convert that to
	// the ROIs docSpace...
	// Assume that the local ROI is in-play as the current document space
	public PVector masterDocSpaceToROIDocSpace(PVector masterDocSpace) {
		return roiManager.masterDocSpaceToSubROIDocSpace(masterDocSpace);

	}

	public boolean isUsingROI() {
		return roiManager.isUsingROI();
	}

	public Range getFullSceneDepthExtrema() {
		return depthBuffer3d.depthBufferExtrema.copy();
	}

	////////////////////////////////////////////////////////////////
	//
	// get pixel data
	//
	public float getCurrentRender01Value(PVector docSpace) {
		Color rgb = getCurrentRenderColor(docSpace);
		int r = rgb.getRed();
		int g = rgb.getGreen();
		int b = rgb.getBlue();
		return (r + g + b) / 765f;
	}

	Color getCurrentRenderColor(PVector docSpace) {
		PVector masterSpace = subROIDocSpaceToMasterDocSpace(docSpace);

		PVector coord = getDepthBufferKeyImageSampler().docSpaceToBufferSpace(masterSpace);
		int packedCol = currentTextureMapImage.getRGB((int) coord.x, (int) coord.y);

		return MOPackedColor.packedIntToColor(packedCol, currentRenderKeyImageHasAlpha);
	}

	public PVector getCurrentRenderGradiant(PVector docSpace) {
		PVector masterSpace = subROIDocSpaceToMasterDocSpace(docSpace);
		ConvolutionFilter cf = new ConvolutionFilter();

		PVector grad = cf.getGradient(masterSpace, currentTextureMapImage);
		return grad;
	}

	public boolean isSubstance(PVector docSpace) {
		PVector masterSpace = subROIDocSpaceToMasterDocSpace(docSpace);
		PVector coord = getDepthBufferKeyImageSampler().docSpaceToBufferSpace(masterSpace);
		return depthBuffer3d.isSubstance((int) coord.x, (int) coord.y);
	}

	public PVector get3DSurfacePoint(PVector docSpace) {
		PVector masterSpace = subROIDocSpaceToMasterDocSpace(docSpace);
		return depthBuffer3d.docSpaceToWorld3D(masterSpace);
	}
	
	public PVector docSpaceToWorld3D(PVector docSpace, float depth) {
		return depthBuffer3d.docSpaceToWorld3D(docSpace, depth);
	}
	
	public Ray3D castRayIntoScene(PVector docSpace) {
		PVector rayOrigin = docSpaceToWorld3D(docSpace, 1);
		PVector rayNormal = new PVector(0,0,1);
		return new Ray3D(rayOrigin,rayNormal);
	}

	/*
	PVector get3DVolumePoint(PVector docSpace, float normDepth) {
		PVector masterSpace = subROIDocSpaceToMasterDocSpace(docSpace);

		// needs to take angle into consideration but OK for the moment
		float realDistance = depthBuffer3d.normalisedDepthToRealDepth(normDepth);

		return depthBuffer3d.docSpaceToWorld3D(masterSpace, realDistance);
	}
	*/

	public float get3DScale(PVector ROIdocSpace) {
		// Returns the document-space distance in master units, that is the unit 3D distance (1.0) at master document space point in the 3D scene.
		// so for points further away the distance will be shorter etc.
		// Used for scaling things accurately against the scene
		
		PVector masterSpace = subROIDocSpaceToMasterDocSpace(ROIdocSpace);
		PVector displacedPointMasterSpace = depthBuffer3d.get3DDisplacedDocPoint(masterSpace, new PVector(0, 1,0));
		PVector displacedPointROIDocSpace =  this.masterDocSpaceToROIDocSpace(displacedPointMasterSpace);
		
		//if( unitSizeMasterDocSpace > 0.002) System.out.println("get3DScale : ROI doc point " + docSpace.toStr() + " masterSpace doc point " +  masterSpace.toStr() + " p3d " + original3DPoint + " unit size " + unitSizeMasterDocSpace);

		float distanceInROIDocSpace = ROIdocSpace.dist(displacedPointROIDocSpace);
		return distanceInROIDocSpace;
	}

	

	public float getDepth(PVector docSpace) {
		PVector roiSpace = subROIDocSpaceToMasterDocSpace(docSpace);
		PVector bufferSpace = depthBuffer3d.docSpaceToBufferSpace(roiSpace);
		return depthBuffer3d.getDepthBilinear(bufferSpace);
	}
	
	/*
	public float getDepthNormalised(PVector docSpace) {
		PVector roiSpace = subROIDocSpaceToMasterDocSpace(docSpace);
		PVector bufferSpace = depthBuffer3d.docSpaceToBufferSpace(roiSpace);
		return depthBuffer3d.getDepthNormalised(bufferSpace);
	}
	*/

	public PVector world3DToDocSpace(PVector world3dPt) {

		PVector docSpaceInMasterView = depthBuffer3d.world3DToDocSpace(world3dPt);
		return masterDocSpaceToROIDocSpace(docSpaceInMasterView);

	}
	
	
	

}


















