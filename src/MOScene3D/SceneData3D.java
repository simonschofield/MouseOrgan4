package MOScene3D;



import java.awt.Color;
import java.awt.image.BufferedImage;
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;

import MOApplication.ROIManager;
import MOImage.ConvolutionFilter;
import MOImage.FloatImage;
import MOImage.ImageDimensions;
import MOImage.ImageProcessing;
import MOImage.MOPackedColor;
import MOImageCollections.DirectoryFileNameScanner;
import MOImageCollections.ImageAssetGroup;

import MOMaths.PVector;
import MOMaths.Range;
import MOMaths.Rect;
import MOSprite.Sprite;
import MOUtils.GlobalSettings;
import MOUtils.ImageCoordinateSystem;
import MOUtils.KeyValuePairList;
import MOUtils.MOStringUtils;
///////////////////////////////////////////////////////////////////////
//
// SceneData3D provides a wrapper class for data exported from the 3D viewing application.
// The data is 1/ a Depth Buffer, read into an internal depthBuffer3D class
// 2/ A set of texture maps. Textures and the Depth buffer have the same dimensions.
// The class also utilises a ROI manager to convert coordinates from SubROI space to Master space
// and vice versa. The document space for the master render and the internal Depth and Textures buffers are the same.  finally accessed using the master do space
// So the master render has to be the same aspect as the SceneData. This is enabled through the createROIManager(int masterRenderWidth) method
// that returns a ROI manager with the correct master render sizes set up already.
// 
//
//
public class SceneData3D {
	///////////////////////////////////////////////////////////////////////
	// path to the specified scenedata folder
	String directoryPath;

	///////////////////////////////////////////////////////////////////////
	// this reads in and contains all the png files within the input folder
	ImageAssetGroup textureMapImages;
	BufferedImage currentTextureMapImage;
	boolean currentRenderKeyImageHasAlpha;

	///////////////////////////////////////////////////////////////////////
	// Depth Buffer and Eye point calculations are made using the Geometry Buffer
	public DepthBuffer3D depthBuffer3d;

	///////////////////////////////////////////////////////////////////////
	// The roi manager should be generated by the this class for any session using SceneData3D
	// as the ROI manager's "master" render needs to be the same aspect as the Scenedata3D buffers. 
	// 
	private ROIManager roiManager;

	

	public SceneData3D(String targetDirectory) {
		directoryPath = targetDirectory;
		FloatImage depthImage = new FloatImage(directoryPath + "\\depth.data");

		float cameraDistToVP = getCameraDistToVPFromFile(directoryPath + "\\view.txt");

		depthBuffer3d = new DepthBuffer3D(depthImage, cameraDistToVP);
		
		// create a default ROIManager. This will probably be user-specified later
		roiManager = createROIManager(3000);
		
		
		GlobalSettings.setSceneData3D(this);
		
	}

	
	
	public void loadTexturemaps(String[] include) {
		
		DirectoryFileNameScanner dfns = new DirectoryFileNameScanner(directoryPath, "png");

		
		if(include!=null) {
			include = MOStringUtils.addToStringList(include, "blank");
			dfns.keep(include);
			System.out.println("SceneData3D is loading " + dfns.getNumFiles() + " texturemaps");
			dfns.printToConsoleShortFileNames();
		}else {
			System.out.println("SceneData3D loading all texture maps. " + dfns.getNumFiles() + " in total");
		}
		

		textureMapImages = new ImageAssetGroup();
		textureMapImages.setDirectoryFileNameScanner(dfns);
		textureMapImages.loadImages();
		setCurrentRenderImage(0);
		
	}
	
	public ROIManager createROIManager(int masterRenderWidth) {
		int renderheight = (int) (masterRenderWidth/this.getAspect());
		roiManager = new ROIManager(masterRenderWidth, renderheight);
		return roiManager;
	}
	
	
	public ImageDimensions getImageDimensions() {
		return new ImageDimensions(depthBuffer3d.width, depthBuffer3d.height);
		
	}
	
	public float getAspect() {
		return depthBuffer3d.width/(float)depthBuffer3d.height;
	}
	
	public Rect getDocumentSpaceRect() {
		return depthBuffer3d.depthBufferCoordinateSystem.getDocumentRect();
	}

	private float getCameraDistToVPFromFile(String fileAndPath) {
		// there should be a file in the SceneData called "view.txt" exported from
		// TerrainMaker v1_3
		float camDist = 0;
		KeyValuePairList kvlist = new KeyValuePairList();
		try {
			BufferedReader csvReader = new BufferedReader(new FileReader(fileAndPath));
			String row;
			while ((row = csvReader.readLine()) != null) {
				//System.out.println("reading " + row);
				
				kvlist.ingestCSVLine(row);
				
			}
			csvReader.close();
		} catch (Exception e) {
			System.out.println("SpriteSeedBatch.loadSeedsAsCSV: csv reader failed - " + fileAndPath + e);
		}
		//kvlist.printMe();
		camDist = kvlist.getFloat("CAMDIST_TO_VP");
		return camDist;
	}

	

	//public Rect getROIRect() {
	//	return roiManager.getCurrentROIDocRect();
	//}

	private ImageCoordinateSystem getDepthBufferCoordinateSystem() {
		return depthBuffer3d.depthBufferCoordinateSystem;
	}
	
	

	/////////////////////////////////////////////////////////////////////////////////////
	// The mask image is an image reflecting the sky/land pixels
	// land pixels are set to white, sky to black

	public ArrayList<String> getRenderImageNames() {
		return textureMapImages.getImageAssetNamesList();
	}

	public BufferedImage setCurrentRenderImage(String shortName) {
		currentTextureMapImage = textureMapImages.getImage(shortName);
		currentRenderKeyImageHasAlpha = ImageProcessing.hasAlpha(currentTextureMapImage);
		return currentTextureMapImage;
	}

	public void setCurrentRenderImage(int n) {
		currentTextureMapImage = textureMapImages.getImage(n);
		String shortName = textureMapImages.getImageAssetName(n);
		System.out.println("curren render image is " + shortName);
		currentRenderKeyImageHasAlpha = ImageProcessing.hasAlpha(currentTextureMapImage);
	}

	////////////////////////////////////////////////////////////////
	//
	// get images
	//
	public BufferedImage getSubstanceMaskImage(boolean cropToRoi) {
		if (cropToRoi)
			return cropToROI(depthBuffer3d.substanceImage);
		return depthBuffer3d.substanceImage;
	}

	public BufferedImage getCurrentRenderImage(boolean cropToRoi) {
		if (cropToRoi)
			return cropToROI(currentTextureMapImage);
		return currentTextureMapImage;
	}

	public BufferedImage getRenderImage(String shortName, boolean cropToRoi) {
		BufferedImage renderImage = textureMapImages.getImage(shortName);
		if (cropToRoi)
			return cropToROI(renderImage);
		return renderImage;
	}

	////////////////////////////////////////////////////////////////
	//
	// when using the ROI, you may wish to see the portion of the render in the SceneData texture collection
	// This method crops the image accordingly

	BufferedImage cropToROI(BufferedImage uncropped) {
		// returns the roi cropped image from whatever function
		// System.out.println("cropping to roi rect " + roiRect.toStr());
		Rect currentROIDocSpaceRect = roiManager.getCurrentROIDocRect();
		Rect masterDocSpaceRect = roiManager.getMasterDocumentRect();
		// this needs to be normalised within the master rect
		PVector topLeft = masterDocSpaceRect.norm(   currentROIDocSpaceRect.getTopLeft()   );
		PVector bottomRight = masterDocSpaceRect.norm(   currentROIDocSpaceRect.getBottomRight()   );
		Rect cropRect = new Rect(topLeft, bottomRight);
		//System.out.println("warning using untested cropToROI in scenedata class");
		return ImageProcessing.cropImageWithNormalisedRect(uncropped, cropRect);
	}

	
	

	public boolean isUsingROI() {
		return roiManager.isUsingROI();
	}

	public Range getFullSceneDepthExtrema() {
		return depthBuffer3d.getDepthExtrema().copy();
	}

	////////////////////////////////////////////////////////////////
	//
	// get pixel data
	//
	public float getCurrentRender01Value(PVector docSpace) {
		Color rgb = getCurrentRenderColor(docSpace);
		int r = rgb.getRed();
		int g = rgb.getGreen();
		int b = rgb.getBlue();
		return (r + g + b) / 765f;
	}
	
	

	Color getCurrentRenderColor(PVector docSpace) {
		PVector coord = getDepthBufferCoordinateSystem().docSpaceToBufferSpaceClamped(docSpace);
		//System.out.println("Buffer space pt = " + coord.toStr());
		int packedCol = currentTextureMapImage.getRGB((int) coord.x, (int) coord.y);
		return MOPackedColor.packedIntToColor(packedCol, currentRenderKeyImageHasAlpha);
	}

	public PVector getCurrentRenderGradiant(PVector docSpace) {
		ConvolutionFilter cf = new ConvolutionFilter();

		PVector grad = cf.getGradient(docSpace, currentTextureMapImage);
		return grad;
	}

	public boolean isSubstance(PVector docSpace) {
		PVector coord = getDepthBufferCoordinateSystem().docSpaceToBufferSpace(docSpace);
		return depthBuffer3d.isSubstance((int) coord.x, (int) coord.y);
	}

	public PVector get3DSurfacePoint(PVector docSpace) {
		return depthBuffer3d.docSpaceToWorld3D(docSpace);
	}
	
	public PVector get3DVolumePoint(PVector docSpace, float depth) {
		return depthBuffer3d.docSpaceToWorld3D(docSpace, depth);
	}
	
	public Ray3D castRayIntoScene(PVector docSpace) {
		PVector rayOrigin = get3DVolumePoint(docSpace, 1);
		PVector rayNormal = new PVector(0,0,1);
		return new Ray3D(rayOrigin,rayNormal);
	}

	public float get3DScale(PVector ROIdocSpace) {
		// Returns the document-space distance in master units, that is the unit 3D distance (1.0) at master document space point in the 3D scene.
		// so for points further away the distance will be shorter etc.
		// Used for scaling things accurately against the scene
		PVector displacedPointDocSpace = depthBuffer3d.get3DDisplacedDocPoint(ROIdocSpace, new PVector(0, -1,0));
		
		//if( unitSizeMasterDocSpace > 0.002) System.out.println("get3DScale : ROI doc point " + docSpace.toStr() + " masterSpace doc point " +  masterSpace.toStr() + " p3d " + original3DPoint + " unit size " + unitSizeMasterDocSpace);

		return ROIdocSpace.dist(displacedPointDocSpace);
	}

	

	public float getDepth(PVector docSpace) {
		
		PVector bufferSpace = depthBuffer3d.docSpaceToBufferSpace(docSpace);
		return depthBuffer3d.getDepthBilinear(bufferSpace);
	}
	
	
	public float getNormalisedDepth(PVector docSpace) {
		// useful for applying effect based on depth, such as fog and depth sensitive packing
		// The normalisation is between the near Z and far Z of the full depthBuffer, where the 
		// Respective returned values are nearZ -> 0, farZ -> 1
		float worldDepth =  getDepth(docSpace);
		return depthBuffer3d.normaliseDepth(worldDepth);
	}
	
	
	public PVector world3DToDocSpace(PVector world3dPt) {

		return  depthBuffer3d.world3DToDocSpace(world3dPt);
		

	}
	
	
	////////////////////////////////////////////////////////////////////////////////////////////
	// raySurfaceIntersection - finds the intersection point between the "surface" (- i.e. the 3D values implicit in the
	// depth buffer, as a continuous surface)  and a ray. If there is no intersection, returns null
	//
	// To find the intersection point between a ray and a point on the SceneData3D surface an iterative solution has to be used as the surface is non-geometric (undulating). 
	// This algorithm establishes a "topPlane" (maxY) and "basePlane" (minY) for the whole scene and works out the ray intersections to find a Line3D in this space. 
	// If the line3d penetrates the surface then it uses the ray-marching method findClosestPointOnLineToSurface
	// to return the closest point found to the surface, on the line.
	// If you require an actual surface point use project3DPointToSurface(closestLinePoint)
	//
	public PVector raySurfaceIntersection(Ray3D ray) {
		// constructs a base plane at the lowest and highest points,  finds the intersection point.
		AABox3D worldExtents = depthBuffer3d.getExtents();
		PVector basePlanePoint =  worldExtents.getMin();
		PVector topPlanePoint =  worldExtents.getMax();
		PVector basePlaneIntersectionPoint = Util3D.getPlaneInYIntersection(ray, basePlanePoint);
		PVector topPlaneIntersectionPoint = Util3D.getPlaneInYIntersection(ray, topPlanePoint);
	
		// makes a 3D search line. This should definitely intersect the surface (starts above, ends below)
		Line3D searchLine = new Line3D(topPlaneIntersectionPoint, basePlaneIntersectionPoint);

		return  findClosestPointOnLineToSurface(searchLine);
		
	}
	
	////////////////////////////////////////////////////////////////////////////////
	// takes an arbitrary point in 3D and projects in onto the surface along the eye line.
	// Returns the surface point.

	public PVector project3DPointToSurface(PVector p3d) {
		// first line will always return a value, even if the point is outside of document space, as we have all the data for the projection.
		PVector docSpace = this.world3DToDocSpace(p3d);

		// if the docSpace is outside the depth buffer, the depth value is clamped to the over-stepped edge value of the z buffer. This provides a reasonable result
		return this.get3DSurfacePoint(docSpace);
	}



	////////////////////////////////////////////////////////////////////////////////////////////
	// Private methods associated with raySurfaceIntersection
	// This finds the approximate intersection between a Line3D and a SceneDat3D surface. 
	// It uses ray marching with numSamples accuracy. To work well, the line is assumed to penetrate the surface at some point.
	// so some sort of pre-processing should be done to establish this, otherwise it still returns the closes point, but this may be a way-off. 
	// 
	// If we project the start and end of the line into 2D, and measure the distance, this should give the optimum number of samples, except the samples will
	// not be evenly spaced in 3D due to perspective
	//
	// if a 3D point on the line projects to a point on the surface
	private PVector findClosestPointOnLineToSurface(Line3D line3) {
		
		
		if( line3DPenetratesSurface(line3) == false) {
			return getNearestEndToSurface( line3);
		}
			
		
		PVector lineStart = line3.p1;
		PVector lineEnd = line3.p2;

		// calculates the optimum number of iterations based on a projected 2D line
		PVector line2DStartDS  = this.world3DToDocSpace(lineStart);
		PVector line2DEndDS  = this.world3DToDocSpace(lineEnd);
		
		PVector line2DStartBS = this.getDepthBufferCoordinateSystem().docSpaceToBufferSpaceClamped(line2DStartDS);
		PVector line2DEndBS = this.getDepthBufferCoordinateSystem().docSpaceToBufferSpaceClamped(line2DEndDS);
		
		int numSamples = (int) line2DStartBS.dist(line2DEndBS);
		
		// the first pass find the approximate points each side (returned in the form of a Line3D). This is then processed again...
		Line3D firstPass =  findClosestPointsEachSideOfSurface(line3, numSamples);
		// ...in the second pass. Increase 10 for a more accurate result.
		Line3D secondPass =  findClosestPointsEachSideOfSurface(firstPass, 10);
		
		
		
		//return closestPointOnLineToSurface;
		PVector closestPointOnLineToSurface = secondPass.getMidPoint();
		
		boolean debugFlag = false;
		if(debugFlag) {
			PVector closestPointOnSurface =  project3DPointToSurface(closestPointOnLineToSurface);
			float closestDistance = closestPointOnSurface.dist(closestPointOnLineToSurface);
			System.out.println(">>in method findClosestPointOnLineToSurface closestPointOnLine " + closestPointOnLineToSurface.toStr() + " closestPointOnSurface " + 
								closestPointOnSurface + " distance " + closestDistance + " out of total linelen " + line3.length());
		}

		return closestPointOnLineToSurface;

		
	}
	
	////////////////////////////////////////////////////////////////////////////////////////////
	// uses ray-marching on the line to get the 2 closest points-on-line to the surface - one in-front of the surface
	// and one behind the surface. Returns the result as a new, shorter line, which can be resubmitted to this algorithm for 
	// a finer search
	private Line3D findClosestPointsEachSideOfSurface(Line3D lineIn, int numIterations) {
		
		float closestNearDistance = -1000000f;
		float closestFarDistance = 1000000f;
		
		PVector closestNearPointOnLineToSurface = null;
		PVector closestFarPointOnLineToSurface = null;
		
		
		float step = 1f/numIterations; 
		for(int n = 0; n <= numIterations; n++) {
			float control = step*n;
			PVector linePt3D = lineIn.lerp(control);

			float signedDistance = getSignedDistanceToSurface(linePt3D);
			
			if(signedDistance < 0) {
				// this is a "near" point, on this side of the surface
				if(signedDistance > closestNearDistance) {
					closestNearDistance = signedDistance;
					closestNearPointOnLineToSurface = linePt3D;
				}
			} else {
				// this is a "far" point, on the other side of the surface
				if(signedDistance < closestFarDistance) {
					closestFarDistance = signedDistance;
					closestFarPointOnLineToSurface = linePt3D;
				}
			}

		}
		
		return new Line3D(closestNearPointOnLineToSurface, closestFarPointOnLineToSurface);
		
	}
	
	PVector getNearestEndToSurface(Line3D line3) {
		// used as a failsafe if the line is not penetrating th visible surface
		float p1Dist = getDistanceToSurface(line3.p1);
		float p2Dist = getDistanceToSurface(line3.p2);
		
		if(p1Dist < p2Dist) {
			return line3.p1;
		}
		
		return line3.p2;
		
	}
	/////////////////////////////////////////////////////////////////////////////////
	// Determines whether or not a line penetrates the surface
	private boolean line3DPenetratesSurface(Line3D line) {
		
		// do a "health check" to see if one point is in front, and the other behind the surface
		float signedDistanceStartPt = getSignedDistanceToSurface(line.p1);
		float signedDistanceEndPt = getSignedDistanceToSurface(line.p2);
				
		if((signedDistanceStartPt*signedDistanceEndPt) > 0) {
			// if both distances multiplied do NOT == a -ve number, the they are both the same side of the surface, so do not penetrate
			//
			// System.out.println("line3DPenetratesSurface:: error - the line does not penetrate the. End points are " + line.toStr() + " distances are " + signedDistanceStartPt + "," + signedDistanceEndPt);
			return false;
		}
				
		return true;
		
		
	}
	
	
	/////////////////////////////////////////////////////////////////////////////////
	// takes an arbitrary point in 3D and projects in onto the surface.
	// returns the distance. If it is in-front of the surface (nearer to the camera than the surface)  the distance is negative. If 
	// the point is "behind" the surface (further away from the camera than the surface point) the distance is positive
	private float getSignedDistanceToSurface(PVector p3d) {

		PVector surfacePoint = project3DPointToSurface(p3d);
		float unsignedDistance = surfacePoint.dist(p3d);
		if(p3d.z < surfacePoint.z) {
			// nearer than the surface point
			return unsignedDistance*-1;
		}
		
		return unsignedDistance;
	}
	
	public float getDistanceToSurface(PVector p3d) {
		
		PVector surfacePoint = project3DPointToSurface( p3d);
		return surfacePoint.dist(p3d);
		
	}
	
	
	
}


















