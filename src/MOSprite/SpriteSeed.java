package MOSprite;



import MOMaths.PVector;
import MOUtils.GlobalSettings;
import MOUtils.KeyValuePairList;
import MOUtils.UniqueID;
//////////////////////////////////////////////////////////////////////////////////
// A SpriteSeed contains Identification Data (SeedBatch, Tag and Unique ID) and Scene Positional Data generated by some point-generation system or simulation
// The tag is so that the generating system is able to influence the final sprite in any other arbitrary ways
//
// A better name might be SpriteSpawnPoint, but seed is OK.
//
//
// It is given to a sprite font to generate a repeatable and complete sprite
// 
// A SpriteSeed is generated by a system such as a point-generator or more sophisticated simulation, sometimes in a completely different application. It can be saved/read to file, usually as a SeedBatch. It stores
// the location and other geometric data decided by the generating system, and has a "tag" string variable for anything else decided. 
// Importantly, it has a unique ID, used throughout the life of both the Seed and Sprite, and is used to seed random streams in order to ensure repeatable results between sessions.
// It also contains the seed-generator name, for selection purposes by the user.

public class SpriteSeed {
	
	////////////////////////////////////////////////////
	// This is the unique ID generator, shared between all seeds. It is instanced when the first
	// seed is made. So IF you want to guarantee unique ID then all sprites
	// should be forged using seeds
	static UniqueID uniqueIDSource;   
	
	
	
	
	
	////////////////////////////////////////////////////
	// For Identification purposes - the seed-generator name.
	// this enables the user to identify seeds from different batches
	public String SeedBatchName = "";
	
	////////////////////////////////////////////////////
	// For Identification purposes
	// this enables the creating system to add a tag if it needs to
	public String SeedTag = "";
	
	////////////////////////////////////////////////////
	// For Identification purposes only
	// the id is a unique integer. It is set by the constructor from the static UniqueID class declared above. 
	// 
	// regardless of previous random events
	// It is also used in optimisations such as registering whether or not a seed is used in a render.
	private int uniqueID;

	/////////////////////////////////////////////////////
	// This is a Unique ID set by the generating seed batch. It is used to guarantee
	// the same results for the same seed in this batch by seeding random streams
	// it encounters
	private int randomKey;
	
	/////////////////////////////////////////////////////
	// Geometric transforms applied
	
	// the doc point of the seed
	// used to position (translate) the item
	public float docPointX = 0;
	public float docPointY = 0;

	// scale
	public float scale = 1;

	//Rotation, in degrees clockwise
	//where 0 represent the "up" of the image
	public float rotation = 0;

	// flip in x and y
	public boolean flipX = false;
	public boolean flipY = false;

	/////////////////////////////////////////////////////
	// the depth is set to the normalised depth in the 3D scene, 
	// usually used to sort the render order of the seeds
	// 
	public float depth = 1;

	// this is so that you can turn sprites on and off in clipping/culling processes
	// This is not saved/loaded to/from file
	public boolean isActive = true;
	
	public SpriteSeed() {
		if(uniqueIDSource == null) {
			uniqueIDSource = new UniqueID();
		}
		this.uniqueID = uniqueIDSource.getUniqueID();
		this.randomKey = this.uniqueID;
	}
	
	public SpriteSeed(int ranKey) {
		// this is the constructor called by the SeedBatch
		if(uniqueIDSource == null) {
			uniqueIDSource = new UniqueID();
		}
		this.uniqueID = uniqueIDSource.getUniqueID();
		this.randomKey = ranKey;
	}
	
	
	public SpriteSeed copy() {
		SpriteSeed cpy = new SpriteSeed();
		
		cpy.SeedBatchName = this.SeedBatchName;
		cpy.SeedTag = this.SeedTag;
		cpy.uniqueID = this.uniqueID;
		cpy.randomKey = this.randomKey;
		cpy.docPointX = this.docPointX;
		cpy.docPointY = this.docPointY;
		cpy.scale  = this.scale;
		cpy.rotation  = this.rotation;
		cpy.flipX  = this.flipX;
		cpy.flipY  = this.flipY;
		cpy.depth = this.depth;
		cpy.isActive = this.isActive;
		
		return cpy;
		
	}
	
	
	public PVector getDocPoint() {
		return new PVector(docPointX, docPointY, 0);
	}


	public void setDocPoint(PVector p) {
		docPointX = p.x;
		docPointY = p.y;
	}

	PVector getDocPointWithDepth() {
		return new PVector(docPointX, docPointY, depth);
	}

	float getDepth() {
		return depth;
	}

	public void setDepth(float d) {
		depth = d;
	}

	public boolean batchNameEquals(String query) {
		return SeedBatchName.equals(query);
	}
	
	public boolean batchNameContains(String query) {
		return SeedBatchName.contains(query);
	}
	
	public int getRandomKey() {
		return randomKey;
	}
	
	public int getUniqueID() {
		return uniqueID;
	}

	public String getAsCSVStr() {
		// Called by a File Saving operation to gather the full line of CSV data
		// In order eliminate differing aspect issues between the generating system and the reading system
		// all XY locations are saved to file in NORMALISED coordinates and then converted to local documentSpace

		KeyValuePairList kvlist = new KeyValuePairList();
		kvlist.addKeyValue("SeedBatchName", SeedBatchName);
		kvlist.addKeyValue("SeedTag", SeedTag);
		kvlist.addKeyValue("UniqueId", uniqueID);
		kvlist.addKeyValue("RandomKey", randomKey);
		
		PVector np = docSpaceToNormalisedSpace(new PVector(docPointX, docPointY));
		kvlist.addKeyValue("DocPointX", np.x);
		kvlist.addKeyValue("DocPointY", np.y);
		
		kvlist.addKeyValue("Scale", scale);
		kvlist.addKeyValue("Rotation", rotation);
		kvlist.addKeyValue("FlipX", flipX);
		kvlist.addKeyValue("FlipY", flipY);
		kvlist.addKeyValue("Depth", depth);
		//kvlist.addKeyValue("IsActive", isActive);
		
		String line =  kvlist.getAsCSVLine();
		
		return line;

	}

	void setWithCSVStr(String csvStr) {
		// Called by a File Loading operation upon reading a full line of CSV information.
		// In order eliminate differing aspect issues between the generating system and the using system
		// all XY locations are converted from local documentSpace and saved to file in NORMALISED coordinates
		
		KeyValuePairList kvlist = new KeyValuePairList();
		kvlist.ingestCSVLine(csvStr);
		
		SeedBatchName = kvlist.getString("SeedBatchName");
		SeedTag = kvlist.getString("SeedTag");
		uniqueID = kvlist.getInt("UniqueId");
		randomKey = kvlist.getInt("RandomKey");
		
		float npX = kvlist.getFloat("DocPointX");
		float npY = kvlist.getFloat("DocPointY");
		PVector dpt = normalisedSpaceToDocSpace(new PVector(npX, npY));
		setDocPoint(dpt);
		
		scale = kvlist.getFloat("Scale");
		rotation = kvlist.getFloat("Rotation");
		flipX = kvlist.getBoolean("FlipX");
		flipY = kvlist.getBoolean("FlipY");
		depth = kvlist.getFloat("Depth");
		//isActive = kvlist.getBoolean("IsActive");
		
		

		//System.out.println("Loading seed: " + this.getAsCSVStr());

	}

	PVector normalisedSpaceToDocSpace(PVector normPt) {
		return GlobalSettings.getTheDocumentCoordSystem().normalisedSpaceToDocSpace( normPt);
	}

	PVector docSpaceToNormalisedSpace(PVector docPt) {
		return GlobalSettings.getTheDocumentCoordSystem().docSpaceToNormalisedSpace(getDocPoint());
	}
	

}
