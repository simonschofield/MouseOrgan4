package MOSprite;



import MOMaths.PVector;
import MOUtils.GlobalSettings;
import MOUtils.KeyValuePairList;
import MOUtils.UniqueID;
//////////////////////////////////////////////////////////////////////////////////
// A SpriteSeed contains Identification Data (SeedBatch, Tag and Unique ID) and Scene Positional Data generated by some point-generation system or simulation
// The tag is so that the generating system is able to influence the final sprite in any other arbitrary ways
//
// It is given to a sprite font to generate a repeatable and complete sprite
// 
// A SpriteSeed is possibly generated by some other system
// such as a point-generator or more sophisticated simulation. It can be saved/read to file, usually as a SeedBatch. It represents
// the location and other geometric data decided by the generating system. It is probably going to be used by a sprite in locating it within the scene.
// It has a unique ID, which is picked up by the Sprite it helps generate. This ensures that the ID is unique throughout the life of both the Seed and Sprite
// and is maintained in file. This ID is then used to ensure repeatable random streams between sessions.


public class SpriteSeed {
	
	////////////////////////////////////////////////////
	// This is the unique ID generator, shared between all seeds. It is instanced when the first
	// seed is made. So IF you want to guarantee unitque ID then all sprites
	// should be forged using seeds
	static UniqueID uniqueIDSource;   
	

	
	
	////////////////////////////////////////////////////
	// For Identification purposes
	// this enables the user to identify seeds from different batches
	public String SeedBatchName = "";
	
	////////////////////////////////////////////////////
	// For Identification purposes
	// this enables the creating system to add a tag if it needs to
	public String SeedTag = "";
	
	////////////////////////////////////////////////////
	// For Identification purposes
	// the id is a unique integer. It is set by the constructor from the static UniqueID class declared above. 
	// This is used in seeding the sprite's random number generator, thereby ensuring the same random events happen to each seed
	// regardless of previous random events
	// It is also used in optimisations such as registering whether or not a seed is used in a render.
	public int id;

	
	/////////////////////////////////////////////////////
	// Geometric transforms applied
	
	// the doc point of the seed
	// used to position (translate) the item
	public float docPointX = 0;
	public float docPointY = 0;

	// scale
	public float scale = 1;

	//Rotation, in degrees clockwise
	//where 0 represent the "up" of the image
	public float rotation = 0;

	// flip in x and y
	public boolean flipX = false;
	public boolean flipY = false;

	/////////////////////////////////////////////////////
	// the depth is set to the normalised depth in the 3D scene, 
	// usually used to sort the render order of the seeds
	// 
	public float depth = 1;

	// this is so that you can turn sprites on and off in clipping/culling processes
	// This is not saved/loaded to/from file
	public boolean isActive = true;
	
	public SpriteSeed() {
		if(uniqueIDSource == null) {
			uniqueIDSource = new UniqueID();
		}
		this.id = uniqueIDSource.getUniqueID();
	}
	
	public SpriteSeed copy() {
		SpriteSeed cpy = new SpriteSeed();
		
		cpy.SeedBatchName = this.SeedBatchName;
		cpy.SeedTag = this.SeedTag;
		cpy.id = this.id;
		cpy.docPointX = this.docPointX;
		cpy.docPointY = this.docPointY;
		cpy.scale  = this.scale;
		cpy.rotation  = this.rotation;
		cpy.flipX  = this.flipX;
		cpy.flipY  = this.flipY;
		cpy.depth = this.depth;
		cpy.isActive = this.isActive;
		
		return cpy;
		
	}
	
	
	public PVector getDocPoint() {
		return new PVector(docPointX, docPointY, 0);
	}


	public void setDocPoint(PVector p) {
		docPointX = p.x;
		docPointY = p.y;
	}

	PVector getDocPointWithDepth() {
		return new PVector(docPointX, docPointY, depth);
	}

	float getDepth() {
		return depth;
	}

	public void setDepth(float d) {
		depth = d;
	}



	public String getAsCSVStr() {
		// Called by a File Saving operation to gather the full line of CSV data
		// In order eliminate differing aspect issues between the generating system and the reading system
		// all XY locations are saved to file in NORMALISED coordinates and then converted to documentSpace

		KeyValuePairList kvlist = new KeyValuePairList();
		kvlist.addKeyValue("SeedBatchName", SeedBatchName);
		kvlist.addKeyValue("SeedTag", SeedTag);
		kvlist.addKeyValue("Id", id);
		
		
		PVector np = docSpaceToNormalisedSpace(new PVector(docPointX, docPointY));
		kvlist.addKeyValue("DocPointX", np.x);
		kvlist.addKeyValue("DocPointY", np.y);
		
		kvlist.addKeyValue("Scale", scale);
		kvlist.addKeyValue("Rotation", rotation);
		kvlist.addKeyValue("FlipX", flipX);
		kvlist.addKeyValue("FlipY", flipY);
		kvlist.addKeyValue("Depth", depth);
		//kvlist.addKeyValue("IsActive", isActive);
		
		String line =  kvlist.getAsCSVLine();
		
		return line;

	}

	void setWithCSVStr(String csvStr) {
		// Called by a File Loading operation upon reading a full line of CSV information.
		// In order eliminate differing aspect issues between the generating system and the using system
		// all XY locations are converted from documentSpace and saved to file in NORMALISED coordinates
		
		KeyValuePairList kvlist = new KeyValuePairList();
		kvlist.ingestCSVLine(csvStr);
		
		SeedBatchName = kvlist.getString("SeedBatchName");
		SeedTag = kvlist.getString("SeedTag");
		id = kvlist.getInt("Id");
		
		float npX = kvlist.getFloat("DocPointX");
		float npY = kvlist.getFloat("DocPointY");
		PVector dpt = normalisedSpaceToDocSpace(new PVector(npX, npY));
		setDocPoint(dpt);
		
		scale = kvlist.getFloat("Scale");
		rotation = kvlist.getFloat("Rotation");
		flipX = kvlist.getBoolean("FlipX");
		flipY = kvlist.getBoolean("FlipY");
		depth = kvlist.getFloat("Depth");
		//isActive = kvlist.getBoolean("IsActive");
		
		

		//System.out.println("Loading seed: " + this.getAsCSVStr());

	}

	PVector normalisedSpaceToDocSpace(PVector normPt) {
		return GlobalSettings.getTheDocumentCoordSystem().normalisedSpaceToDocSpace( normPt);
	}

	PVector docSpaceToNormalisedSpace(PVector docPt) {
		return GlobalSettings.getTheDocumentCoordSystem().docSpaceToNormalisedSpace(getDocPoint());
	}
	

}
