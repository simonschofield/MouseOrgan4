package MOSprite;



import MOMaths.PVector;
import MOUtils.GlobalSettings;
import MOUtils.KeyValuePairList;
import MOUtils.UniqueID;
//////////////////////////////////////////////////////////////////////////////////
// A SpriteSeed contains Identification Data (SeedBatch, Tag and Unique ID) and Scene Positional Data generated by some point-generation system or simulation
// The tag is so that the generating system is able to influence the final sprite in any other arbitrary ways
//
// A better name might be SpriteSpawnPoint, but seed is OK.
//
//
// It is given to a sprite font to generate a repeatable and complete sprite
// 
// A SpriteSeed is generated by a system such as a point-generator or more sophisticated simulation, sometimes in a completely different application. It can be saved/read to file, usually as a SeedBatch. It stores
// the location and other geometric data decided by the generating system, and has a "tag" string variable for anything else decided. 
// Importantly, it has a unique ID, used throughout the life of both the Seed and Sprite, and is used to seed random streams in order to ensure repeatable results between sessions.
// It also contains the seed-generator name, for selection purposes by the user.

public class SpriteSeed {

	////////////////////////////////////////////////////
	// For Identification purposes - the seed-generator name.
	// this enables the user to identify seeds from different batches
	public String SeedBatchName = "";
	
	
	////////////////////////////////////////////////////
	// For Identification purposes only
	// the id is a unique integer. It is set by the constructor from the static UniqueID class declared above. 
	// 
	// regardless of previous random events
	// It is also used in optimisations such as registering whether or not a seed is used in a render.
	private int uniqueID;

	/////////////////////////////////////////////////////
	// This is a Unique ID set by the generating seed batch. It is used to guarantee
	// the same results for the same seed in this batch by seeding random streams
	// it encounters. It set here, rather than later on in the sprite itself,  as it may be used in the actual Sprite instantiating processes
	// such as a SpriteFont, where it may be used to determine the associated image asset. In order to control this, we cannot use the UniqueID. 
	private int randomKey;
	
	/////////////////////////////////////////////////////
	// Geometric transforms applied
	
	// the doc point of the seed
	// used to position (translate) the item
	//public float docPointX = 0;
	//public float docPointY = 0;
    PVector docPoint;
	
	/////////////////////////////////////////////////////
    // For a 3D scene the depth defines the drawing order and scale of the item.
    // The depth is set to the real 3D unit depth in the 3D scene. 
    // Although the depth can also be recovered at run time from the scene.
    // In the case of a 2D scene, the depth can be used 
    // to define the drawing order
	// 
	// 
	public float depth = 1;

	/////////////////////////////////////////////////////
	// this is so that you can turn sprites on and off in clipping/culling processes
	// This is not saved/loaded to/from file
	public boolean isActive = true;
	
	public SpriteSeed() {
		
		this.uniqueID = GlobalSettings.getNextUniqueID();
		this.randomKey = this.uniqueID;
	}
	

	public SpriteSeed copy() {
		SpriteSeed cpy = new SpriteSeed();
		
		cpy.SeedBatchName = this.SeedBatchName;
		
		cpy.uniqueID = this.uniqueID;
		cpy.randomKey = this.randomKey;
		cpy.docPoint = this.docPoint.copy();
		cpy.depth = this.depth;
		cpy.isActive = this.isActive;
		
		return cpy;
		
	}
	
	
	public PVector getDocPoint() {
		return docPoint;
	}


	public void setDocPoint(PVector p) {
		docPoint = new PVector();
		docPoint.x = p.x;
		docPoint.y = p.y;
		docPoint.z = 0;
	}

	PVector getDocPointWithDepth() {
		return new PVector(docPoint.x, docPoint.y, depth);
	}

	float getDepth() {
		return depth;
	}

	public void setDepth(float d) {
		depth = d;
	}

	public boolean batchNameEquals(String query) {
		return SeedBatchName.equals(query);
	}
	
	public boolean batchNameContains(String query) {
		return SeedBatchName.contains(query);
	}
	
	public int getRandomKey() {
		return randomKey;
	}
	
	public int getUniqueID() {
		return uniqueID;
	}
	
	public KeyValuePairList getAsKeyValuePairList() {
		KeyValuePairList kvlist = new KeyValuePairList();
		kvlist.addKeyValue("SeedBatchName", SeedBatchName);
		kvlist.addKeyValue("UniqueId", uniqueID);
		kvlist.addKeyValue("RandomKey", randomKey);
		kvlist.addKeyValue("DocPoint", docPoint.array());
		kvlist.addKeyValue("Depth", depth);
		kvlist.addKeyValue("IsActive", isActive);
		return kvlist;
	}

	public String getAsCSVStr() {
		// Called by a File Saving operation to gather the full line of CSV data
		String line =  getAsKeyValuePairList().getAsCSVLine();
		
		return line;

	}

	void setWithCSVStr(String csvStr) {
		// Called by a File Loading operation upon reading a full line of CSV information.
		// In order eliminate differing aspect issues between the generating system and the using system
		// all XY locations are converted from local documentSpace and saved to file in NORMALISED coordinates
		
		KeyValuePairList kvlist = new KeyValuePairList();
		kvlist.ingestCSVLine(csvStr);
		
		SeedBatchName = kvlist.getString("SeedBatchName");
		uniqueID = kvlist.getInt("UniqueId");
		randomKey = kvlist.getInt("RandomKey");
		
		float[] pv = kvlist.getVector("DocPoint");
		
		
		// we need to convert them back into the master document space, not the current ROI space!
		// PVector dpt = normalisedSpaceToDocSpace(new PVector(npX, npY));
		PVector p = new PVector();
		p.set(pv);
		setDocPoint(p);
		
		
		depth = kvlist.getFloat("Depth");

		//System.out.println("Loading seed: " + this.getAsCSVStr());

	}
	
	


}
